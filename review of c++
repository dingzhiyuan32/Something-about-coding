Mac 编译 c++ in Terminal
g++ Hello.cpp
./a.out
或g++ Hello.cpp -o filename
./filename

IOStream
std::cout << "Hello, world!" << std::endl;
std::cin >> a >> b;

volatile：告诉编译程序，该变量值可能按程序中没有显示说明的方式改变，防止编译器作不正确的优化。

作用域分辨符：::
eg     class_name::member
全局作用域分辨符：::
eg
int x;
void f()
{
  int x;
  x=2;        // 局部X
  ::x=10;    // 全局X
}

指针是通过地址间接访问某个变量，而引用是通过别名直接访问某个变量，对引用的操作就是对被引用的变量的操作。
int &b=a;  // b是a的别名；
b=b+10;    // 对b的改变，实际上改变的是a；
引用在定义时必须初始化；初始化后，不能改变引用的“指向”。
可以用某个引用的地址值赋给一个指针，而指针则指向被引用的变量。
int a=10; int &b=a;
int *p;  p=&b;    // 则p指向a
当引用被创建时，它必须被初始化；
一个引用被初始化为“引用”某个对象，它就不能改变为另一个对象的引用
不能有“空”引用，必须保证引用是和一块合法的存储单元相联系。

new & delete
new: 从“堆”中动态分配存储块。
delete: 从“堆”中动态删除存储块。
用new生成对象时,会调用构造函数, 用malloc则不会;同样,用delete删除对象时,会调用析构函数, 用free则不会.

函数的定义
<类型><函数名>(<参数表>){〈若干条语句〉}
定义在先，调用在后，调用前可以不必声明；
定义在后，调用在前，调用前必须声明。
声明 <类型> <函数名>(<参数表>)；

函数的引用传递和值传递
值传递：把实际参数的值复制给形式参数，也就是说，形参和实参是两个不同的内存空间。函数所处理的仅仅是实际参数的一个拷贝。
引用传递：把实际参数的地址传递给形式参数，也就是说，形参和实参实际上是同一个内存空间。函数通过对形式参数的处理来达到对实际参数进行加工的目的。
  形参声明为引用量；
  函数体直接对引用量操作； 

c++访问控制Public/private/protected
Public: 公有成员，其后声明的所有成员可以被所有的人访问。
Private:私有成员，除了该类型的创建者和类的内部成员函数之外，任何人不能访问。
Protected:保护成员，与Private基本相同，区别是继承的结构可以访问Protected成员，但不可以访问Private 成员。
友元friend:访问私有部分。友元可以是外部全局函数、类或类的成员函数。

class的成员默认为Private;
struct的成员默认为Public.

当类的public成员函数f返回对该类private成员m的非const引用时，如果f的调用作为赋值语句的左值，则访问控制不起作用，对象的使用者可以直接存取m的值。
  称这种情形为访问控制的“陷阱”。
利用const填补这个陷阱

构造函数跟类同名，可以带参数，没有返回值。
构造函数应声明为public（但不是必须），否则无法创建对象。
如果没有提供任何构造函数，编译器会创建一个默认的构造函数

析构函数：类的特殊成员函数，在撤销对象时自动调用该函数。通常做一些撤销对象前的回收工作。
析构函数不带参数，没有返回值；不能够重载。析构函数必须是public函数。

成员变量可以是基本类型、构造类型，甚至是一个类的对象（必须提前定义）、对象指针或引用（必须提前声明）。
成员函数可以在类的定义体外定义或在定义体内直接定义。
创建对象：类 对象1，对象2。。。
类中的每个成员函数都隐式地声明this指针；

c++中的const
c++不为const创建存储空间，而是保存在“符号表”里，即“编译时常量”
默认情况下为内部连接，仅在const被定义过的文件里可见
定义const时必须赋值，除非用extern说明
如果想用运行期间产生的值初始化一个变量，并且知道在该变量的生命期内其值不变，则可用const限定该变量，达到最大限度地保证改变量安全性的目的
const对象：对象被初始化后，它的数据成员在其生命期内不被改变。
在成员函数的声明和定义后面加上const使之成为const成员函数。int const_f() const;其中const_f()是const函数，保证不修改x2;
声明为const的对象是不能被赋值的。声明为const的对象不能随便调用任意的成员函数。声明为const的对象只能调用声明为const的成员函数。
const的成员函数不能改变成员变量

namespace:把一个全局名字空间分成多个可管理的小空间(名字空间)，从而减少名字冲突。
Using namespace 名字空间名   using 指令，把一个名字空间的名字导入另一个名字空间

c++中的静态数据成员拥有一块独立的存储区，不管创建了多少该类的对象。
静态成员函数是为类的全体对象服务而不是类的特殊对象服务。类的静态成员函数不能访问一般的数据成员和成员函数，只能访问静态数据成员和成员函数。

运算符重载
type  classname::operator@(arg_list)
type operator@(arg_list)
不能改变内部算符的优先级、结合顺序及运算符的目数；
 . ,*, ::, ?:, sizeof五种运算符不能重载。
