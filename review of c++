Mac 编译 c++ in Terminal
g++ Hello.cpp
./a.out
或g++ Hello.cpp -o filename
./filename

IOStream
std::cout << "Hello, world!" << std::endl;
std::cin >> a >> b;

volatile：告诉编译程序，该变量值可能按程序中没有显示说明的方式改变，防止编译器作不正确的优化。

作用域分辨符：::
eg     class_name::member
全局作用域分辨符：::
eg
int x;
void f()
{
  int x;
  x=2;        // 局部X
  ::x=10;    // 全局X
}


指针是通过地址间接访问某个变量，而引用是通过别名直接访问某个变量，对引用的操作就是对被引用的变量的操作。
int &b=a;  // b是a的别名；
b=b+10;    // 对b的改变，实际上改变的是a；
引用在定义时必须初始化；初始化后，不能改变引用的“指向”。
可以用某个引用的地址值赋给一个指针，而指针则指向被引用的变量。
int a=10; int &b=a;
int *p;  p=&b;    // 则p指向a

new & delete
new: 从“堆”中动态分配存储块。
delete: 从“堆”中动态删除存储块。
用new生成对象时,会调用构造函数, 用malloc则不会;同样,用delete删除对象时,会调用析构函数, 用free则不会.

函数的定义
<类型><函数名>(<参数表>){〈若干条语句〉}
定义在先，调用在后，调用前可以不必声明；
定义在后，调用在前，调用前必须声明。
声明 <类型> <函数名>(<参数表>)；

函数的引用传递和值传递
值传递：把实际参数的值复制给形式参数，也就是说，形参和实参是两个不同的内存空间。函数所处理的仅仅是实际参数的一个拷贝。
引用传递：把实际参数的地址传递给形式参数，也就是说，形参和实参实际上是同一个内存空间。函数通过对形式参数的处理来达到对实际参数进行加工的目的。
  形参声明为引用量；
  函数体直接对引用量操作； 

c++访问控制Public/private/protected
Public: 公有成员，其后声明的所有成员可以被所有的人访问。
Private:私有成员，除了该类型的创建者和类的内部成员函数之外，任何人不能访问。
Protected:保护成员，与Private基本相同，区别是继承的结构可以访问Protected成员，但不可以访问Private 成员。
友元friend:访问私有部分。友元可以是外部全局函数、类或类的成员函数。

class的成员默认为Private;
struct的成员默认为Public.

当类的public成员函数f返回对该类private成员m的非const引用时，如果f的调用作为赋值语句的左值，则访问控制不起作用，对象的使用者可以直接存取m的值。
  称这种情形为访问控制的“陷阱”。
利用const填补这个陷阱

构造函数跟类同名，可以带参数，没有返回值。
构造函数应声明为public（但不是必须），否则无法创建对象。
如果没有提供任何构造函数，编译器会创建一个默认的构造函数

析构函数：类的特殊成员函数，在撤销对象时自动调用该函数。通常做一些撤销对象前的回收工作。
析构函数不带参数，没有返回值；不能够重载。析构函数必须是public函数。
